# Tasks: [FEATURE NAME]

**Status**: No## Format: `[ID] [P?] Description`
**[P]** = Can run in parallel (different files, no dependencies)
Include exact file paths in descriptions

**⚠️ CRITICAL - MCP Tool Paths (SSE Transport)**:
- **ALWAYS use ABSOLUTE paths** for MCP tools: `create_simics_project()`, `build_simics_project()`, `run_simics_test()`
- **NEVER use relative paths** like `"./simics-project"` or `"../project"`
- **WHY**: SSE transport MCP servers run in different process/directory context
- **HOW**: Use `os.getcwd()` or workspace root to construct: `"/full/path/to/workspace/simics-project"`
- **Example**: `create_simics_project(project_path="/home/user/workspace/simics-project")`tarted | In Progress | Completed | Blocked
**Input**: Design documents from `/specs/[###-feature-name]/`
**Prerequisites**: plan.md (required), data-model.md, contracts/

## Execution Flow (main)
```
1. Load plan.md → Extract: tech stack, libraries, structure
2. Load design docs:
   → data-model.md: Extract entities → model tasks
   → contracts/: Each file → contract test task
   → Simics: Extract register definitions → DML file tasks (after project structure is generated by MCP server)
3. Generate tasks by category:
   → Setup: project init, dependencies, linting
   → **Knowledge Gates** (before tests/implementation):
     • Research Review: Read research.md → extract architecture decisions, patterns, constraints
     • **Simics**: DML Learning Gate → Read DML_grammar.md before implementation
     • RAG Queries: Add before tests and implementation phases
   → Tests: contract tests, integration tests
   → Core: models, services, CLI commands
   → Integration: DB, middleware, logging
   → Polish: unit tests, performance, docs
4. Apply task rules:
   → Different files = mark [P] for parallel
   → Same file = sequential (no [P])
   → Research review before tests/implementation
   → RAG queries before implementation
   → Tests before implementation (TDD)
5. Number tasks sequentially (T001, T002...)
6. Generate dependency graph
7. Create parallel execution examples
8. Validate task completeness:
   → All contracts have tests?
   → All entities have models?
   → All endpoints implemented?
   → Research review task before tests?
   → RAG queries before knowledge-intensive tasks?
9. Return: SUCCESS (tasks ready for execution)
```

## Format: `[ID] [P?] Description`
- **[P]**: Can run in parallel (different files, no dependencies)
- Include exact file paths in descriptions

## Path Conventions
- **Single project**: `src/`, `tests/` at repository root
- **Web app**: `backend/src/`, `frontend/src/`
- **Mobile**: `api/src/`, `ios/src/` or `android/src/`
- **Simics**: `./simics-project/modules/device-name/`, `./simics-project/modules/device-name/test/` at repository root

## Phase 3.1: Setup
- [ ] T001 Create project structure per implementation plan
- [ ] T002 Initialize [language] project with [framework] dependencies
- [ ] T003 [P] Configure linting and formatting tools

**Simics Setup:**
- [ ] T001 Verify connection: `get_simics_version()`
- [ ] T002 Create project: `create_simics_project(project_path="/absolute/path/to/workspace/simics-project")` ⚠️ ABSOLUTE PATH
- [ ] T003 Add skeleton: `add_dml_device_skeleton(project_path="/absolute/path/to/workspace/simics-project", device_name="DEVICE_NAME")` ⚠️ ABSOLUTE PATH
- [ ] T004 Checkout DMLC: `checkout_and_build_dmlc(project_path="/absolute/path/to/workspace/simics-project")` ⚠️ ABSOLUTE PATH
- [ ] T005 [P] Verify build: `build_simics_project(project_path="/absolute/path/to/workspace/simics-project", module="DEVICE_NAME")` ⚠️ ABSOLUTE PATH

## Phase 3.2: Tests First (TDD) ⚠️ MUST COMPLETE BEFORE 3.3
**CRITICAL: These tests MUST be written and MUST FAIL before ANY implementation**
- [ ] T004 **GATE**: Read research.md → extract key decisions, patterns, constraints → document in implementation notes
- [ ] T005 [P] Contract test POST /api/users in tests/contract/test_users_post.py
- [ ] T006 [P] Contract test GET /api/users/{id} in tests/contract/test_users_get.py
- [ ] T007 [P] Integration test user registration in tests/integration/test_registration.py
- [ ] T008 [P] Integration test auth flow in tests/integration/test_auth.py

**Simics:**
- [ ] T006 **GATE**: Read research.md → extract architecture decisions, MCP tool outputs, design patterns → document in implementation notes
- [ ] T007 [P] **RAG Query**: Execute `perform_rag_query("Simics Python device testing register read write verification patterns", source_type="python", match_count=10)` for test patterns
- [ ] T008 [P] Register access test - implement using RAG patterns
- [ ] T009 [P] Interface behavior test - implement using RAG patterns
- [ ] T010 [P] Device workflow test - implement using RAG patterns
- [ ] T011 [P] Validate test environment: `run_simics_test(project_path="/absolute/path/to/workspace/simics-project", suite="modules/DEVICE_NAME/test")` ⚠️ ABSOLUTE PATH

## Phase 3.3: Core Implementation (ONLY after tests are failing)

**⚠️ CRITICAL BUILD REQUIREMENT (Simics Projects)**:
After implementing EACH task in this phase, MUST run `build_simics_project(project_path="/absolute/path/to/workspace/simics-project", module="DEVICE_NAME")` to verify compilation before marking task done. Do NOT proceed to next task if build fails.

- [ ] T008 [P] User model in src/models/user.py
- [ ] T009 [P] UserService CRUD in src/services/user_service.py
- [ ] T010 [P] CLI --create-user in src/cli/user_commands.py
- [ ] T011 POST /api/users endpoint
- [ ] T012 GET /api/users/{id} endpoint
- [ ] T013 Input validation
- [ ] T014 Error handling and logging

**Simics Project:**
- [ ] T011 **GATE**: Read .specify/memory/DML_grammar.md → document in implementation notes
- [ ] T012 **GATE**: Review study notes
- [ ] T013 **GATE**: Read device skeleton
- [ ] T014 [P] **RAG Query**: Execute `perform_rag_query("DML 1.4 register bank implementation io_memory interface patterns", source_type="dml", match_count=10)` for register patterns
- [ ] T015 [P] Register definitions (apply grammar + best practices + RAG patterns)
- [ ] T016 [P] Interface declarations (apply grammar + best practices + RAG patterns)
- [ ] T017 [P] Check DML: `check_with_dmlc(project_path="/absolute/path/to/workspace/simics-project", module="DEVICE_NAME")` ⚠️ ABSOLUTE PATH (validates with AI diagnostics)
- [ ] T018 [P] Build: `build_simics_project(project_path="/absolute/path/to/workspace/simics-project", module="DEVICE_NAME")` ⚠️ ABSOLUTE PATH
- [ ] T019-T022 Register logic, state management, error handling, validation

## Phase 3.4: Integration
- [ ] T015 Connect UserService to DB
- [ ] T016 Auth middleware
- [ ] T017 Request/response logging
- [ ] T018 CORS and security headers

**Simics Integration Example:**
- [ ] T024 **RAG Query**: Execute `perform_rag_query("DML device memory map transact interrupt signal integration patterns", source_type="dml", match_count=10)` for integration patterns
- [ ] T025 Connect device to memory interface using transact() methods (apply RAG patterns)
- [ ] T026 Implement interrupt line connections and events (apply RAG patterns)
- [ ] T027 Add external port communications and protocols (apply RAG patterns)
- [ ] T028 Integrate with Simics checkpointing and state management (apply RAG patterns)
- [ ] T029 [P] Validate integration: `build_simics_project(project_path="/absolute/path/to/workspace/simics-project")` ⚠️ ABSOLUTE PATH
- [ ] T030 [P] Run comprehensive tests: `run_simics_test(project_path="/absolute/path/to/workspace/simics-project", suite="modules/DEVICE_NAME/test")` ⚠️ ABSOLUTE PATH

## Phase 3.5: Polish
- [ ] T019 [P] Unit tests for validation in tests/unit/test_validation.py
- [ ] T020 Performance tests (<200ms)
- [ ] T021 [P] Update docs/api.md
- [ ] T022 Remove duplication
- [ ] T023 Run manual-testing.md

## Dependencies

**General**: Setup → Research Review → Tests → Implementation → Integration → Polish

**Simics**:
- T001-T005 (Setup) → T006 (Research Review) → T007-T011 (Test RAG + Tests) → T012-T014 (DML Learning) → T015+ (Implementation RAG + Implementation) → Integration → Polish
- **Key**: Setup → Research review → Test RAG + Tests → DML learning → Implementation RAG + Implementation → Integration RAG + Integration → Polish


## Parallel Example
```
# Launch T004-T007 together:
Task: "Contract test POST /api/users in tests/contract/test_users_post.py"
Task: "Contract test GET /api/users/{id} in tests/contract/test_users_get.py"
Task: "Integration test registration in tests/integration/test_registration.py"
Task: "Integration test auth in tests/integration/test_auth.py"
```

## Notes
- [P] tasks = different files, no dependencies
- Verify tests fail before implementing
- Commit after each task
- Avoid: vague tasks, same file conflicts

## Task Generation Rules
*Applied during main() execution*

1. **From Contracts**: Each file → contract test [P], each endpoint → implementation
2. **From Data Model**: Each entity → model [P], relationships → services
3. **From User Stories**: Each story → integration test [P], quickstart → validation
4. **Ordering**:
   - General: Setup → Research Review → Tests → Implementation → Integration → Polish
   - **Simics**: Setup → Research Review → Test RAG Query → Tests → DML Learning → Implementation RAG Query → Implementation → Integration RAG Query → Integration → Polish

## Validation Checklist
*GATE: Checked by main() before returning*

- [ ] All contracts have corresponding tests
- [ ] All entities have model tasks
- [ ] All tests come before implementation
- [ ] Parallel tasks truly independent
- [ ] Each task specifies exact file path
- [ ] No task modifies same file as another [P] task

**Simics-Specific Validation:**
- [ ] **All MCP tool calls use ABSOLUTE paths** (SSE transport requirement)
- [ ] All MCP tool calls specify correct project_path parameter
- [ ] Build validation tasks after implementation changes
- [ ] Test execution tasks use appropriate suite parameter
- [ ] Device name consistently used across MCP tool calls
- [ ] RAG queries placed before implementation tasks that need knowledge
- [ ] All RAG query results guide subsequent implementation tasks

## Critical Gates

### Research Review Gate (All Projects):
- [ ] Read research.md completely
- [ ] Extract and document in implementation notes:
  - **Architecture Decisions**: Key design choices, rationale
  - **Device Architecture Context**: High-level device patterns (Simics only)
  - **Patterns & Best Practices**: Coding patterns, conventions
  - **Constraints**: Technical limitations, requirements
  - **Dependencies**: Libraries, versions, compatibility notes
  - **MCP Tool Outputs**: Simics version, packages, platform info (if applicable)
- [ ] Verify comprehensive notes before writing tests

**What's in research.md**:
- Environment discovery results (MCP tool outputs)
- High-level device architecture overview (1-2 RAG queries for context)
- Architecture decisions from spec.md analysis
- Design implications for implementation

**What's NOT in research.md** (gathered during implementation):
- Detailed register implementation patterns → Use RAG during implementation
- Specific callback/method code → Use RAG during error recovery
- Test code examples → Use RAG before writing tests
- Error handling details → Use RAG during debugging

### DML Learning Gate (Simics Projects):
- [ ] Read DML_grammar.md completely
- [ ] Document learnings in implementation notes: "## DML Grammar Study Notes"
- [ ] Verify comprehensive notes before starting DML implementation

**Note**: Tests are written using RAG query patterns first, and don't require deep DML study yet

## Execution Rules
1. **Prerequisites**: Verify plan.md and data-model.md exist
2. **Research Review**: Read research.md BEFORE writing tests or implementation (all projects)
3. **RAG Before Implementation**: Execute RAG queries BEFORE implementing tests or features
4. **DML Learning**: DML learning gate before ANY DML implementation (Simics only)
5. **Tests First**: Tests written using RAG patterns, before DML learning (Simics only)
6. **Study Notes**: Must reference in all DML tasks (Simics only)
7. **MCP Absolute Paths**: ALWAYS use absolute paths for `create_simics_project()`, `build_simics_project()`, `run_simics_test()` (SSE transport requirement)

## Common Failures
- ❌ Skip research.md review before tests/implementation
- ❌ Skip DML learning gate (Simics only)
- ❌ Incomplete study notes (Simics only)
- ❌ Ignore study notes during implementation (Simics only)
- ❌ Test after DML learning (should be before, Simics only)
- ❌ Skip RAG queries before implementation
- ❌ **Use relative paths for MCP tools** (must be absolute for SSE transport)
- ✅ **Correct**: Setup → Research review → RAG query → tests → DML learning → RAG query → implementation → absolute paths for all MCP calls

## Error Recovery (Simics)

**CRITICAL**: DO NOT guess fixes. Always use RAG queries with error-specific query strings to get solutions and examples.

### Build Errors

**Step 1: Extract Error Information**
**REQUIRED**: Use `check_with_dmlc(project_path="/absolute/path/to/workspace/simics-project", module="DEVICE_NAME")` to get AI-enhanced diagnostics.

From the diagnostic output, identify:
- **Error type**: syntax | semantic | template | pattern
- **Error keyword**: Core error term (e.g., "expected ';'", "unknown attribute")
- **Error context**: Affected construct (e.g., "register declaration", "interface method")
- **Error location**: File path + line number
- **AI suggestions**: Review any automatic fix suggestions provided by the tool

**Step 2: Document Diagnostic Information**
Create or append to `.specify/dml_diagnostics.md`:
```markdown
## Error: [Error Keyword] - [Date]
**Location**: [file:line]
**Type**: [syntax|semantic|template|pattern]
**Context**: [Affected construct]

### Diagnostic Output
[Paste check_with_dmlc output including AI suggestions]

### Solution Applied
[To be filled after Step 6]
```

**Step 3: Check Study Notes (If Available)**
If DML study notes exist from learning gate:
1. Search "DML Grammar Study Notes" → syntax/declaration issues
2. On match → Apply pattern, skip to Step 6
3. On no match → Continue to Step 4

**Step 4: Query for Solution (Max 2 Attempts)**

**Attempt 1 - Specific Query:**
```python
perform_rag_query(
    query=f"DML 1.4 {error_keyword} {error_context} fix solution example",
    source_type="dml",  # or "docs" for grammar/syntax errors
    match_count=10
)
```

**If no relevant results, Attempt 2 - Broadened Query:**
```python
perform_rag_query(
    query=f"DML 1.4 {error_type} common issues examples",
    source_type="docs",
    match_count=15
)
```

**Query Pattern Examples:**
- `"syntax error: expected ';'"` → `"DML 1.4 register declaration semicolon syntax"`
- `"unknown attribute"` → `"DML 1.4 attribute declarations scoping"`
- `"template not found"` → `"DML 1.4 template inheritance interface"`

**Step 5: Review RAG Results**
- Examine code examples showing correct usage
- Identify pattern differences from your implementation
- Note relevant documentation excerpts

**Step 6: Apply Fix**
- Use examples as reference (adapt, don't copy blindly)
- Ensure fix aligns with Grammar study notes (if available)
- Apply to your specific use case

**Step 7: Verify & Iterate**
```bash
build_simics_project(project_path="/absolute/path/to/workspace/simics-project", module="DEVICE_NAME")
```
- ✅ **Build succeeds** → Continue to Step 8
- ❌ **Same error** → Try Attempt 2 query or escalate
- ⚠️ **New error** → Return to Step 1 with new error

**Step 8: Document Solution (Only If Build Succeeded)**
Update the diagnostic entry in `.specify/dml_diagnostics.md`:
```markdown
### Solution Applied
**Fix Type**: [AI suggestion | RAG pattern | Study notes]
**Changes Made**:
- [Describe the fix applied]
- [Reference specific RAG results or study notes if used]

**Verification**: Build succeeded on [date/time]
```
Then mark task complete.

### Test Failures

**Step 1: Identify Test Failure Type**
- Register access test → read/write/reset behavior
- Interface behavior test → method calls/return values
- Device workflow test → state transitions/events
- Python test framework → assertions/setup/teardown

**Step 2: Query for Solution (Max 2 Attempts)**
```python
# Attempt 1 - Specific
perform_rag_query(
    query=f"Simics Python test {test_scenario} example working code",
    source_type="python",
    match_count=10
)
```

**Query Pattern Examples:**
- `"register read returns wrong value"` → `"Simics Python test register read write verification"`
- `"interface method not found"` → `"Simics Python test interface method invocation"`
- `"device state transition failed"` → `"Simics Python test device state workflow"`

**Step 3: Review RAG Results**
- Examine working test examples
- Identify differences from your test implementation
- Note test patterns and assertions

**Step 4: Apply Fix**
- Adapt test patterns to your specific scenario
- Ensure test aligns with device behavior from spec.md

**Step 5: Verify**
```bash
run_simics_test(project_path="/absolute/path/to/workspace/simics-project", suite="modules/DEVICE_NAME/test")
```

### Runtime Errors

**Step 1: Identify Runtime Issue Type**
- Device behavior → unexpected state/response
- Interface errors → connection/communication failures
- Memory errors → access violations/unmapped regions
- Event/timing → callback/sequence issues

**Step 2: Check Study Notes (If Available)**
If DML study notes exist:
1. Search "DML Best Practices Study Notes" → device behavior patterns
2. On match → Apply pattern, skip to Step 5
3. On no match → Continue to Step 3

**Step 3: Query for Solution (Max 2 Attempts)**
```python
# Attempt 1 - Specific
perform_rag_query(
    query=f"DML 1.4 {error_scenario} {error_context} runtime fix example",
    source_type="dml",
    match_count=10
)
```

**Query Pattern Examples:**
- `"device not responding to memory write"` → `"DML 1.4 memory mapped IO write handler"`
- `"interrupt not firing"` → `"DML 1.4 interrupt signal raise event trigger"`
- `"state not preserved"` → `"DML 1.4 checkpoint state serialization"`

**Step 4: Review RAG Results**
- Examine correct implementation patterns
- Identify behavioral differences
- Note state management approaches

**Step 5: Apply Fix**
- Adapt patterns to your device implementation
- Ensure behavior matches spec.md requirements

**Step 6: Verify**
```bash
build_simics_project(project_path="/absolute/path/to/workspace/simics-project", module="DEVICE_NAME")
run_simics_test(project_path="/absolute/path/to/workspace/simics-project", suite="modules/DEVICE_NAME/test")
```
