# Tasks: [FEATURE NAME]

**Status**: No## Format: `[ID] [P?] Description`
**[P]** = Can run in parallel (different files, no dependencies)
Include exact file paths in descriptions

**⚠️ CRITICAL - MCP Tool Paths (SSE Transport)**:
- **ALWAYS use ABSOLUTE paths** for MCP tools: `create_simics_project()`, `build_simics_project()`, `run_simics_test()`
- **NEVER use relative paths** like `"./simics-project"` or `"../project"`
- **WHY**: SSE transport MCP servers run in different process/directory context
- **HOW**: Use `os.getcwd()` or workspace root to construct: `"/full/path/to/workspace/simics-project"`
- **Example**: `create_simics_project(project_path="/home/user/workspace/simics-project")`tarted | In Progress | Completed | Blocked
**Input**: Design documents from `/specs/[###-feature-name]/`
**Prerequisites**: plan.md (required), data-model.md, contracts/

## Execution Flow (main)
```
1. Load plan.md → Extract: tech stack, libraries, structure
2. Load design docs:
   → data-model.md: Extract entities → model tasks
   → contracts/: Each file → contract test task
   → Simics: Extract register definitions → DML file tasks (after project structure is generated by MCP server)
3. Simics DML Learning:
   → Add T011-T014 at START of Phase 3.3 (implementation)
   → Read DML_Device_Development_Best_Practices.md + DML_grammar.md
   → Document learnings in implementation notes
   → Block all DML implementation until complete
4. Simics RAG Queries:
   → Add RAG query tasks BEFORE tests (T006) and implementation (T015)
   → Query patterns: test frameworks, register implementations, interfaces
5. Generate tasks by category:
   → Setup: project init, dependencies, linting
   → RAG Queries: gather implementation knowledge
   → Tests: contract tests, integration tests
   → Core: models, services, CLI commands
   → Integration: DB, middleware, logging
   → Polish: unit tests, performance, docs
6. Apply task rules:
   → Different files = mark [P] for parallel
   → Same file = sequential (no [P])
   → RAG queries before implementation
   → Tests before implementation (TDD)
7. Number tasks sequentially (T001, T002...)
8. Generate dependency graph
9. Create parallel execution examples
10. Validate task completeness:
   → All contracts have tests?
   → All entities have models?
   → All endpoints implemented?
   → RAG queries before knowledge-intensive tasks?
11. Return: SUCCESS (tasks ready for execution)
```

## Format: `[ID] [P?] Description`
- **[P]**: Can run in parallel (different files, no dependencies)
- Include exact file paths in descriptions

## Path Conventions
- **Single project**: `src/`, `tests/` at repository root
- **Web app**: `backend/src/`, `frontend/src/`
- **Mobile**: `api/src/`, `ios/src/` or `android/src/`
- **Simics**: `./simics-project/modules/device-name/`, `./simics-project/modules/device-name/test/` at repository root

## Phase 3.1: Setup
- [ ] T001 Create project structure per implementation plan
- [ ] T002 Initialize [language] project with [framework] dependencies
- [ ] T003 [P] Configure linting and formatting tools

**Simics Setup:**
- [ ] T001 Verify connection: `get_simics_version()`
- [ ] T002 Create project: `create_simics_project(project_path="/absolute/path/to/workspace/simics-project")` ⚠️ ABSOLUTE PATH
- [ ] T003 Add skeleton: `add_dml_device_skeleton(project_path="/absolute/path/to/workspace/simics-project", device_name="DEVICE_NAME")` ⚠️ ABSOLUTE PATH
- [ ] T004 Checkout DMLC: `checkout_and_build_dmlc(project_path="/absolute/path/to/workspace/simics-project")` ⚠️ ABSOLUTE PATH
- [ ] T005 [P] Verify build: `build_simics_project(project_path="/absolute/path/to/workspace/simics-project", module="DEVICE_NAME")` ⚠️ ABSOLUTE PATH

## Phase 3.2: Tests First (TDD) ⚠️ MUST COMPLETE BEFORE 3.3
**CRITICAL: These tests MUST be written and MUST FAIL before ANY implementation**
- [ ] T004 [P] Contract test POST /api/users in tests/contract/test_users_post.py
- [ ] T005 [P] Contract test GET /api/users/{id} in tests/contract/test_users_get.py
- [ ] T006 [P] Integration test user registration in tests/integration/test_registration.py
- [ ] T007 [P] Integration test auth flow in tests/integration/test_auth.py

**Simics:**
- [ ] T006 [P] **RAG Query**: Execute `perform_rag_query("Simics Python device testing register read write verification patterns", source_type="python", match_count=10)` for test patterns
- [ ] T007 [P] Register access test - implement using RAG patterns
- [ ] T008 [P] Interface behavior test - implement using RAG patterns
- [ ] T009 [P] Device workflow test - implement using RAG patterns
- [ ] T010 [P] Validate test environment: `run_simics_test(project_path="/absolute/path/to/workspace/simics-project", suite="modules/DEVICE_NAME/test")` ⚠️ ABSOLUTE PATH

## Phase 3.3: Core Implementation (ONLY after tests are failing)

**⚠️ CRITICAL BUILD REQUIREMENT (Simics Projects)**:
After implementing EACH task in this phase, MUST run `build_simics_project(project_path="/absolute/path/to/workspace/simics-project", module="DEVICE_NAME")` to verify compilation before marking task done. Do NOT proceed to next task if build fails.

- [ ] T008 [P] User model in src/models/user.py
- [ ] T009 [P] UserService CRUD in src/services/user_service.py
- [ ] T010 [P] CLI --create-user in src/cli/user_commands.py
- [ ] T011 POST /api/users endpoint
- [ ] T012 GET /api/users/{id} endpoint
- [ ] T013 Input validation
- [ ] T014 Error handling and logging

**Simics Project:**
- [ ] T011 **GATE**: Read .specify/memory/DML_Device_Development_Best_Practices.md → document in implementation notes
- [ ] T012 **GATE**: Read .specify/memory/DML_grammar.md → document in implementation notes
- [ ] T013 **GATE**: Review study notes
- [ ] T014 **GATE**: Read device skeleton
- [ ] T015 [P] **RAG Query**: Execute `perform_rag_query("DML 1.4 register bank implementation io_memory interface patterns", source_type="dml", match_count=10)` for register patterns
- [ ] T016 [P] Register definitions (apply grammar + best practices + RAG patterns)
- [ ] T017 [P] Interface declarations (apply grammar + best practices + RAG patterns)
- [ ] T018 [P] Check DML: `check_with_dmlc(project_path="/absolute/path/to/workspace/simics-project", module="DEVICE_NAME")` ⚠️ ABSOLUTE PATH (validates with AI diagnostics)
- [ ] T019 [P] Build: `build_simics_project(project_path="/absolute/path/to/workspace/simics-project", module="DEVICE_NAME")` ⚠️ ABSOLUTE PATH
- [ ] T020-T023 Register logic, state management, error handling, validation

## Phase 3.4: Integration
- [ ] T015 Connect UserService to DB
- [ ] T016 Auth middleware
- [ ] T017 Request/response logging
- [ ] T018 CORS and security headers

**Simics Integration Example:**
- [ ] T024 **RAG Query**: Execute `perform_rag_query("DML device memory map transact interrupt signal integration patterns", source_type="dml", match_count=10)` for integration patterns
- [ ] T025 Connect device to memory interface using transact() methods (apply RAG patterns)
- [ ] T026 Implement interrupt line connections and events (apply RAG patterns)
- [ ] T027 Add external port communications and protocols (apply RAG patterns)
- [ ] T028 Integrate with Simics checkpointing and state management (apply RAG patterns)
- [ ] T029 [P] Validate integration: `build_simics_project(project_path="/absolute/path/to/workspace/simics-project")` ⚠️ ABSOLUTE PATH
- [ ] T030 [P] Run comprehensive tests: `run_simics_test(project_path="/absolute/path/to/workspace/simics-project", suite="modules/DEVICE_NAME/test")` ⚠️ ABSOLUTE PATH

## Phase 3.5: Polish
- [ ] T019 [P] Unit tests for validation in tests/unit/test_validation.py
- [ ] T020 Performance tests (<200ms)
- [ ] T021 [P] Update docs/api.md
- [ ] T022 Remove duplication
- [ ] T023 Run manual-testing.md

## Dependencies

**General**: Tests → Implementation → Polish

**Simics**:
- T001 → T002 → T003 → T004 → T005 → T006-T010 → T011-T023 → T024-T030
- **Key**: Setup (T001-T005) → Test RAG + Tests (T006-T010) → DML learning (T011-T014) → Implementation RAG + Implementation (T015-T023) → Integration RAG + Integration (T024-T030)


## Parallel Example
```
# Launch T004-T007 together:
Task: "Contract test POST /api/users in tests/contract/test_users_post.py"
Task: "Contract test GET /api/users/{id} in tests/contract/test_users_get.py"
Task: "Integration test registration in tests/integration/test_registration.py"
Task: "Integration test auth in tests/integration/test_auth.py"
```

## Notes
- [P] tasks = different files, no dependencies
- Verify tests fail before implementing
- Commit after each task
- Avoid: vague tasks, same file conflicts

## Task Generation Rules
*Applied during main() execution*

1. **From Contracts**: Each file → contract test [P], each endpoint → implementation
2. **From Data Model**: Each entity → model [P], relationships → services
3. **From User Stories**: Each story → integration test [P], quickstart → validation
4. **Ordering**:
   - General: Setup → Tests → Implementation → Integration → Polish
   - **Simics**: Setup → Test RAG Query → Tests → DML Learning → Implementation RAG Query → Implementation → Integration RAG Query → Integration → Polish

## Validation Checklist
*GATE: Checked by main() before returning*

- [ ] All contracts have corresponding tests
- [ ] All entities have model tasks
- [ ] All tests come before implementation
- [ ] Parallel tasks truly independent
- [ ] Each task specifies exact file path
- [ ] No task modifies same file as another [P] task

**Simics-Specific Validation:**
- [ ] **All MCP tool calls use ABSOLUTE paths** (SSE transport requirement)
- [ ] All MCP tool calls specify correct project_path parameter
- [ ] Build validation tasks after implementation changes
- [ ] Test execution tasks use appropriate suite parameter
- [ ] Device name consistently used across MCP tool calls
- [ ] RAG queries placed before implementation tasks that need knowledge
- [ ] All RAG query results guide subsequent implementation tasks

## Critical Gates

### DML Learning Gate (T011-T014):
- [ ] Read DML_Device_Development_Best_Practices.md completely
- [ ] Read DML_grammar.md completely
- [ ] Document learnings in implementation notes: "## DML Best Practices Study Notes" + "## DML Grammar Study Notes"
- [ ] Verify comprehensive notes before T015+

**Note**: Tests (T006-T010) are written using RAG query patterns, don't need deep DML study yet

## Execution Rules
1. **Prerequisites**: Verify plan.md and data-model.md exist
2. **RAG Before Implementation**: Execute RAG queries BEFORE implementing tests or features
3. **DML Learning**: T011-T014 before ANY DML implementation
4. **Tests First**: T006-T010 written using RAG patterns, before DML learning
5. **Study Notes**: Must reference in all DML tasks
6. **MCP Absolute Paths**: ALWAYS use absolute paths for `create_simics_project()`, `build_simics_project()`, `run_simics_test()` (SSE transport requirement)

## Common Failures
- ❌ Skip DML learning (T011-T014)
- ❌ Incomplete study notes
- ❌ Ignore study notes during implementation
- ❌ Test after DML learning (should be before)
- ❌ Skip RAG queries before implementation
- ❌ **Use relative paths for MCP tools** (must be absolute for SSE transport)
- ✅ **Correct**: Setup → RAG query → tests → DML learning → RAG query → implementation → absolute paths for all MCP calls

## Error Recovery (Simics)

**CRITICAL**: DO NOT guess fixes. Always use RAG queries with error-specific query strings to get solutions and examples.

### Build Errors

**Step 1: Extract Error Information**
From build output, identify:
- **Error type**: syntax | semantic | template | pattern
- **Error keyword**: Core error term (e.g., "expected ';'", "unknown attribute")
- **Error context**: Affected construct (e.g., "register declaration", "interface method")
- **Error location**: File path + line number

**Step 2: Check Study Notes (If Available)**
If DML study notes exist from T011-T014:
1. Search "DML Grammar Study Notes" → syntax/declaration issues
2. Search "DML Best Practices Study Notes" → patterns/interfaces
3. On match → Apply pattern, skip to Step 5
4. On no match → Continue to Step 3

**Step 3: Query for Solution (Max 2 Attempts)**

**Attempt 1 - Specific Query:**
```python
perform_rag_query(
    query=f"DML 1.4 {error_keyword} {error_context} fix solution example",
    source_type="dml",  # or "docs" for grammar/syntax errors
    match_count=10
)
```

**If no relevant results, Attempt 2 - Broadened Query:**
```python
perform_rag_query(
    query=f"DML 1.4 {error_type} common issues examples",
    source_type="docs",
    match_count=15
)
```

**Query Pattern Examples:**
- `"syntax error: expected ';'"` → `"DML 1.4 register declaration semicolon syntax"`
- `"unknown attribute"` → `"DML 1.4 attribute declarations scoping"`
- `"template not found"` → `"DML 1.4 template inheritance interface"`

**Step 4: Review RAG Results**
- Examine code examples showing correct usage
- Identify pattern differences from your implementation
- Note relevant documentation excerpts

**Step 5: Apply Fix**
- Use examples as reference (adapt, don't copy blindly)
- Ensure fix aligns with Grammar/Best Practices study notes (if available)
- Apply to your specific use case

**Step 6: Verify & Iterate**
```bash
build_simics_project(project_path="/absolute/path/to/workspace/simics-project", module="DEVICE_NAME")
```
- ✅ **Build succeeds** → Mark task complete
- ❌ **Same error** → Try Attempt 2 query or escalate
- ⚠️ **New error** → Return to Step 1 with new error

### Test Failures

**Step 1: Identify Test Failure Type**
- Register access test → read/write/reset behavior
- Interface behavior test → method calls/return values
- Device workflow test → state transitions/events
- Python test framework → assertions/setup/teardown

**Step 2: Query for Solution (Max 2 Attempts)**
```python
# Attempt 1 - Specific
perform_rag_query(
    query=f"Simics Python test {test_scenario} example working code",
    source_type="python",
    match_count=10
)
```

**Query Pattern Examples:**
- `"register read returns wrong value"` → `"Simics Python test register read write verification"`
- `"interface method not found"` → `"Simics Python test interface method invocation"`
- `"device state transition failed"` → `"Simics Python test device state workflow"`

**Step 3: Review RAG Results**
- Examine working test examples
- Identify differences from your test implementation
- Note test patterns and assertions

**Step 4: Apply Fix**
- Adapt test patterns to your specific scenario
- Ensure test aligns with device behavior from spec.md

**Step 5: Verify**
```bash
run_simics_test(project_path="/absolute/path/to/workspace/simics-project", suite="modules/DEVICE_NAME/test")
```

### Runtime Errors

**Step 1: Identify Runtime Issue Type**
- Device behavior → unexpected state/response
- Interface errors → connection/communication failures
- Memory errors → access violations/unmapped regions
- Event/timing → callback/sequence issues

**Step 2: Check Study Notes (If Available)**
If DML study notes exist:
1. Search "DML Best Practices Study Notes" → device behavior patterns
2. On match → Apply pattern, skip to Step 5
3. On no match → Continue to Step 3

**Step 3: Query for Solution (Max 2 Attempts)**
```python
# Attempt 1 - Specific
perform_rag_query(
    query=f"DML 1.4 {error_scenario} {error_context} runtime fix example",
    source_type="dml",
    match_count=10
)
```

**Query Pattern Examples:**
- `"device not responding to memory write"` → `"DML 1.4 memory mapped IO write handler"`
- `"interrupt not firing"` → `"DML 1.4 interrupt signal raise event trigger"`
- `"state not preserved"` → `"DML 1.4 checkpoint state serialization"`

**Step 4: Review RAG Results**
- Examine correct implementation patterns
- Identify behavioral differences
- Note state management approaches

**Step 5: Apply Fix**
- Adapt patterns to your device implementation
- Ensure behavior matches spec.md requirements

**Step 6: Verify**
```bash
build_simics_project(project_path="/absolute/path/to/workspace/simics-project", module="DEVICE_NAME")
run_simics_test(project_path="/absolute/path/to/workspace/simics-project", suite="modules/DEVICE_NAME/test")
```
