# Tasks: [FEATURE NAME]

**Status**: No## Format: `[ID] [P?] Description`
**[P]** = Can run in parallel (different files, no dependencies)
Include exact file paths in descriptions

**‚ö†Ô∏è CRITICAL - MCP Tool Paths (SSE Transport)**:
- **ALWAYS use ABSOLUTE paths** for MCP tools: `create_simics_project()`, `build_simics_project()`, `run_simics_test()`
- **NEVER use relative paths** like `"./simics-project"` or `"../project"`
- **WHY**: SSE transport MCP servers run in different process/directory context
- **HOW**: Use `os.getcwd()` or workspace root to construct: `"/full/path/to/workspace/simics-project"`
- **Example**: `create_simics_project(project_path="/home/user/workspace/simics-project")`tarted | In Progress | Completed | Blocked
**Input**: Design documents from `/specs/[###-feature-name]/`
**Prerequisites**: plan.md (required), research.md, data-model.md, contracts/

## Execution Flow (main)
```
1. Load plan.md ‚Üí Extract: tech stack, libraries, structure
2. Load design docs:
   ‚Üí data-model.md: Extract entities ‚Üí model tasks
   ‚Üí contracts/: Each file ‚Üí contract test task
   ‚Üí research.md: Extract decisions ‚Üí setup tasks
   ‚Üí Simics: Extract register definitions ‚Üí DML file tasks (after project structure is generated by MCP server)
3. Simics DML Learning:
   ‚Üí Add T017-T018 at START of Phase 3.3 (implementation)
   ‚Üí Read DML_Device_Development_Best_Practices.md + DML_grammar.md
   ‚Üí Document learnings in research.md
   ‚Üí Block all DML implementation until complete
4. Generate tasks by category:
   ‚Üí Setup: project init, dependencies, linting
   ‚Üí Tests: contract tests, integration tests
   ‚Üí Core: models, services, CLI commands
   ‚Üí Integration: DB, middleware, logging
   ‚Üí Polish: unit tests, performance, docs
5. Apply task rules:
   ‚Üí Different files = mark [P] for parallel
   ‚Üí Same file = sequential (no [P])
   ‚Üí Tests before implementation (TDD)
6. Number tasks sequentially (T001, T002...)
7. Generate dependency graph
7. Create parallel execution examples
8. Validate task completeness:
   ‚Üí All contracts have tests?
   ‚Üí All entities have models?
   ‚Üí All endpoints implemented?
9. Return: SUCCESS (tasks ready for execution)
```

## Format: `[ID] [P?] Description`
- **[P]**: Can run in parallel (different files, no dependencies)
- Include exact file paths in descriptions

## Path Conventions
- **Single project**: `src/`, `tests/` at repository root
- **Web app**: `backend/src/`, `frontend/src/`
- **Mobile**: `api/src/`, `ios/src/` or `android/src/`
- **Simics**: `./simics-project/modules/device-name/`, `./simics-project/modules/device-name/test/` at repository root

## Phase 3.1: Setup
- [ ] T001 Create project structure per implementation plan
- [ ] T002 Initialize [language] project with [framework] dependencies
- [ ] T003 [P] Configure linting and formatting tools

**Simics Setup:**
- [ ] T001 Verify connection: `get_simics_version()`
- [ ] T002 Create project: `create_simics_project(project_path="/absolute/path/to/workspace/simics-project")` ‚ö†Ô∏è ABSOLUTE PATH
- [ ] T003 Add skeleton: `add_dml_device_skeleton(project_path="/absolute/path/to/workspace/simics-project", device_name="DEVICE_NAME")` ‚ö†Ô∏è ABSOLUTE PATH
- [ ] T004 Checkout DMLC: `checkout_and_build_dmlc(project_path="/absolute/path/to/workspace/simics-project")` ‚ö†Ô∏è ABSOLUTE PATH
- [ ] T005 [P] Verify build: `build_simics_project(project_path="/absolute/path/to/workspace/simics-project", module="DEVICE_NAME")` ‚ö†Ô∏è ABSOLUTE PATH
- [ ] T006 **GATE**: Verify research.md exists with required RAG results from /plan phase
- [ ] T007-T013 [P] **RAG queries** (OPTIONAL - only if research.md insufficient):
  * T007: DML syntax basics (docs)
  * T008: Python test patterns (python)
  * T009: Device testing strategy (source)
  * T010: Register implementation (dml)
  * T011: State/checkpointing (dml)
  * T012: Interface implementation (dml)
  * T013: Event handling (dml)

## Phase 3.2: Tests First (TDD) ‚ö†Ô∏è MUST COMPLETE BEFORE 3.3
**CRITICAL: These tests MUST be written and MUST FAIL before ANY implementation**
- [ ] T004 [P] Contract test POST /api/users in tests/contract/test_users_post.py
- [ ] T005 [P] Contract test GET /api/users/{id} in tests/contract/test_users_get.py
- [ ] T006 [P] Integration test user registration in tests/integration/test_registration.py
- [ ] T007 [P] Integration test auth flow in tests/integration/test_auth.py

**Simics:**
- [ ] T014 [P] Register access test (use research.md patterns)
- [ ] T015 [P] Interface behavior test
- [ ] T016 [P] Device workflow test
- [ ] T017 [P] Validate test environment: `run_simics_test(project_path="/absolute/path/to/workspace/simics-project", suite="modules/DEVICE_NAME/test")` ‚ö†Ô∏è ABSOLUTE PATH

## Phase 3.3: Core Implementation (ONLY after tests are failing)

**‚ö†Ô∏è CRITICAL BUILD REQUIREMENT (Simics Projects)**:
After implementing EACH task in this phase, MUST run `build_simics_project(project_path="/absolute/path/to/workspace/simics-project", module="DEVICE_NAME")` to verify compilation before marking task done. Do NOT proceed to next task if build fails.

- [ ] T008 [P] User model in src/models/user.py
- [ ] T009 [P] UserService CRUD in src/services/user_service.py
- [ ] T010 [P] CLI --create-user in src/cli/user_commands.py
- [ ] T011 POST /api/users endpoint
- [ ] T012 GET /api/users/{id} endpoint
- [ ] T013 Input validation
- [ ] T014 Error handling and logging

**Simics Project:**
- [ ] T018 **GATE**: Read .specify/memory/DML_Device_Development_Best_Practices.md ‚Üí document in research.md
- [ ] T019 **GATE**: Read .specify/memory/DML_grammar.md ‚Üí document in research.md
- [ ] T020 **GATE**: Review study notes
- [ ] T021 **GATE**: Read device skeleton
- [ ] T022 [P] Register definitions (apply grammar + best practices)
- [ ] T023 [P] Interface declarations (apply grammar + best practices)
- [ ] T024 [P] Check DML: `check_with_dmlc(project_path="/absolute/path/to/workspace/simics-project", module="DEVICE_NAME")` ‚ö†Ô∏è ABSOLUTE PATH (validates with AI diagnostics)
- [ ] T024b **If T024 has errors**: Search memory for solutions: `search_memories(query="[error_keyword] DML compilation", limit=5)` üíæ MEMORY
  - If memory returns relevant solution ‚Üí apply it
  - If memory has no relevant results ‚Üí error is NEW, proceed with manual resolution
- [ ] T025 [P] Build: `build_simics_project(project_path="/absolute/path/to/workspace/simics-project", module="DEVICE_NAME")` ‚ö†Ô∏è ABSOLUTE PATH
- [ ] T025b **After T024-T025, if error was NEW and resolved**: Save solution to memory: `insert_memory(text="ERROR: [error_message] | SOLUTION: [fix_applied] | CONTEXT: [device_name, register/interface affected] | DATE: [date]")` üíæ MEMORY
  - Only save if error was NOT found in memory search (T024b returned no relevant results)
  - Skip if solution came from memory (already stored)
- [ ] T026-T029 Register logic, state management, error handling, validation

## Phase 3.4: Integration
- [ ] T015 Connect UserService to DB
- [ ] T016 Auth middleware
- [ ] T017 Request/response logging
- [ ] T018 CORS and security headers

**Simics Integration Example:**
- [ ] T030 **RAG SEARCH**: Use `perform_rag_query("DML device memory map transact interrupt signal integration patterns", source_type="dml", match_count=5)` for integration patterns
- [ ] T031 Connect device to memory interface using transact() methods
- [ ] T032 Implement interrupt line connections and events
- [ ] T033 Add external port communications and protocols
- [ ] T034 Integrate with Simics checkpointing and state management
- [ ] T035 [P] Validate integration: `build_simics_project(project_path="/absolute/path/to/workspace/simics-project")` ‚ö†Ô∏è ABSOLUTE PATH
- [ ] T036 [P] Run comprehensive tests: `run_simics_test(project_path="/absolute/path/to/workspace/simics-project", suite="modules/DEVICE_NAME/test")` ‚ö†Ô∏è ABSOLUTE PATH

## Phase 3.5: Polish
- [ ] T019 [P] Unit tests for validation in tests/unit/test_validation.py
- [ ] T020 Performance tests (<200ms)
- [ ] T021 [P] Update docs/api.md
- [ ] T022 Remove duplication
- [ ] T023 Run manual-testing.md

## Dependencies

**General**: Tests ‚Üí Implementation ‚Üí Polish

**Simics**:
- T001 ‚Üí T002 ‚Üí T003 ‚Üí T004 ‚Üí T005 ‚Üí T006 ‚Üí T007-T013 ‚Üí T014-T017 ‚Üí T018-T019 ‚Üí T020-T029 ‚Üí T030-T036
- **Key**: research.md (T006) ‚Üí Tests (T014-T017) ‚Üí DML learning (T018-T019) ‚Üí Implementation (T020+) ‚Üí Integration (T030+)


## Parallel Example
```
# Launch T004-T007 together:
Task: "Contract test POST /api/users in tests/contract/test_users_post.py"
Task: "Contract test GET /api/users/{id} in tests/contract/test_users_get.py"
Task: "Integration test registration in tests/integration/test_registration.py"
Task: "Integration test auth in tests/integration/test_auth.py"
```

## Notes
- [P] tasks = different files, no dependencies
- Verify tests fail before implementing
- Commit after each task
- Avoid: vague tasks, same file conflicts

## Task Generation Rules
*Applied during main() execution*

1. **From Contracts**: Each file ‚Üí contract test [P], each endpoint ‚Üí implementation
2. **From Data Model**: Each entity ‚Üí model [P], relationships ‚Üí services
3. **From User Stories**: Each story ‚Üí integration test [P], quickstart ‚Üí validation
4. **Ordering**:
   - General: Setup ‚Üí Tests ‚Üí Implementation ‚Üí Integration ‚Üí Polish
   - **Simics**: Setup ‚Üí Tests (use research.md) ‚Üí DML Learning ‚Üí Implementation ‚Üí Integration ‚Üí Polish

## Validation Checklist
*GATE: Checked by main() before returning*

- [ ] All contracts have corresponding tests
- [ ] All entities have model tasks
- [ ] All tests come before implementation
- [ ] Parallel tasks truly independent
- [ ] Each task specifies exact file path
- [ ] No task modifies same file as another [P] task

**Simics-Specific Validation:**
- [ ] **All MCP tool calls use ABSOLUTE paths** (SSE transport requirement)
- [ ] All MCP tool calls specify correct project_path parameter
- [ ] Build validation tasks after implementation changes
- [ ] Test execution tasks use appropriate suite parameter
- [ ] Device name consistently used across MCP tool calls
- [ ] research.md from /plan phase is available and referenced
- [ ] Optional RAG searches are only used when research.md is insufficient
- [ ] All new RAG search results are documented

## research.md Workflow
**Source**: Created by /plan with comprehensive RAG results
**Usage**: Reference documented patterns (primary source)
**Modifications**: If gaps ‚Üí create tasks to fill, append new RAG results
**Missing**: ERROR - /plan must complete first

## Critical Gates

### Pre-Test Gate (T005):
- [ ] research.md exists with 8 RAG results from /plan
- [ ] Reviewed and understood patterns
- [ ] Identified applicable patterns

### DML Learning Gate (T017-T018):
- [ ] Read DML_Device_Development_Best_Practices.md completely
- [ ] Read DML_grammar.md completely
- [ ] Document in research.md: "## DML Best Practices Study Notes" + "## DML Grammar Study Notes"
- [ ] Verify comprehensive notes before T019+

**Note**: Tests (T013-T016) use research.md patterns, don't need deep DML study

## Execution Rules
1. **Prerequisites**: Verify research.md exists (T005)
2. **DML Learning**: T017-T018 before ANY DML implementation
3. **Tests First**: T013-T016 use research.md, written before DML learning
4. **Study Notes**: Must reference in all DML tasks
5. **RAG Queries**: OPTIONAL - only if research.md/study notes insufficient
6. **MCP Absolute Paths**: ALWAYS use absolute paths for `create_simics_project()`, `build_simics_project()`, `run_simics_test()` (SSE transport requirement)
7. **Memory Tools**: Use `search_memories()` for error resolution, `insert_memory()` to save new solutions (builds institutional knowledge)

## Common Failures
- ‚ùå Skip DML learning (T017-T018)
- ‚ùå Incomplete study notes
- ‚ùå Ignore study notes during implementation
- ‚ùå Test after DML learning (should be before)
- ‚ùå Duplicate RAG queries (check research.md first)
- ‚ùå **Use relative paths for MCP tools** (must be absolute for SSE transport)
- ‚úÖ **Correct**: research.md ‚Üí tests ‚Üí DML learning ‚Üí implementation ‚Üí query only if gaps ‚Üí absolute paths for all MCP calls

## Error Recovery (Simics)

**Priority**: Memory (Institutional Knowledge) ‚Üí Study Notes ‚Üí Source Docs ‚Üí RAG (last resort)

**New vs Known Error Detection**:
- **Known Error**: `search_memories()` returns relevant results with similarity/relevance
- **New Error**: `search_memories()` returns empty/irrelevant results ‚Üí proceed with manual resolution ‚Üí save solution after fixing

### Build Errors
1. **Search Memory**: `search_memories(query="[error_keyword] DML compilation", limit=5)` for previously solved similar errors
   - **If relevant match found** ‚Üí Apply documented solution ‚Üí Skip to step 8 (no save needed)
   - **If no match found** ‚Üí Mark as NEW error ‚Üí Continue to step 2
2. **Check Grammar Notes**: Search research.md "DML Grammar Study Notes"
   - Syntax errors ‚Üí declaration/method/expression syntax
   - Semantic errors ‚Üí scoping/types/visibility
   - Template errors ‚Üí template system/inheritance
3. **Check Best Practices Notes**: Search "DML Best Practices Study Notes"
   - Pattern errors ‚Üí coding patterns/interfaces
   - Common pitfalls ‚Üí anti-patterns section
4. **Check research.md RAG**: Device examples, register patterns from /plan
5. **Read Source**: Open DML_grammar.md or DML_Device_Development_Best_Practices.md, search error keyword
6. **RAG Query**: `perform_rag_query("DML 1.4 [error_keyword] syntax solution", source_type="dml", match_count=10)`
7. **Document & Save**: 
   - Add solution to research.md
   - **If error was NEW (step 1 found nothing)**: Save to memory: `insert_memory(text="ERROR: [error_message] | SOLUTION: [fix_applied] | CONTEXT: [device/register context] | DATE: [date]")`
8. **Verify Fix**: Re-run check/build to confirm resolution

**Examples**:
```
"syntax error: expected ';'" ‚Üí Grammar notes ‚Üí register declaration syntax
"unknown attribute" ‚Üí Grammar notes ‚Üí attribute declarations + scoping
"template not found" ‚Üí Grammar notes ‚Üí template system (might be interface!)
"checkpoint restore failed" ‚Üí Best practices ‚Üí state management patterns
```

### Test Failures
1. **Search Memory**: `search_memories(query="[test_name] Python test failure", limit=5)` for similar test issues
   - **If relevant match found** ‚Üí Apply documented solution ‚Üí Skip to documentation
   - **If no match found** ‚Üí Mark as NEW error ‚Üí Continue to step 2
2. **Check Test Patterns**: research.md test sections from /plan
3. **Check Best Practices**: For device behavior issues
4. **Check Grammar**: For interface/method issues
5. **Debugging**: Apply techniques from best practices notes
6. **RAG Query**: `perform_rag_query("Simics Python test [scenario]", source_type="python")`
7. **Document & Save**: Add to research.md and **if NEW error**: save to memory

### Runtime Errors
1. **Search Memory**: `search_memories(query="[error_type] runtime error", limit=5)` for previously encountered issues
   - **If relevant match found** ‚Üí Apply documented solution ‚Üí Skip to documentation
   - **If no match found** ‚Üí Mark as NEW error ‚Üí Continue to step 2
2. **Check Best Practices** ‚Üí error scenario
3. **Check Grammar** ‚Üí verify syntax correctness
4. **Re-read Source** ‚Üí for complex issues
5. **RAG Query** ‚Üí similar issues + solutions
6. **Document & Save**: Add to research.md and **if NEW error**: save to memory

**Documentation**: After resolving via steps 4-7, update both:
1. Add to research.md:
```markdown
**Error**: [message] ‚Üí **Solution**: [fix] ‚Üí **Reference**: [source]
```
2. Save to memory: `insert_memory(text="ERROR: [error_message] | SOLUTION: [fix_applied] | CONTEXT: [device/test/runtime context] | DATE: [date]")`
