/* -*- coding: utf-8 -*-
  This Software is part of Intel Simics. The rights to copy, distribute,
  modify, or otherwise make use of this Software may be licensed only
  pursuant to the terms of an applicable Intel license agreement.

  © 2025 Intel Corporation
*/
// WARNING: This file is automatically generated from IP-XACT for watchdog-timer

dml 1.4;
device watchdog_timer;
param desc = "ARM PrimeCell Watchdog Timer device model";
import "watchdog-timer-registers.dml";
import "simics/devs/signal.dml";

// Internal state variables
saved cycles_t counter_start_time;
saved uint64 counter_start_value;
saved bool timer_enabled;
saved bool interrupt_pending;
saved bool reset_pending;
saved bool locked;
saved bool test_mode;

// USER-TODO: add configuration attributes here, if needed.

// Basic bank declaration is in watchdog-timer-registers.dml,
// here is the register implementation with side-effects.
bank apb_bus is apb_bus_temp {
    register WDOGLOAD {
        method write_register(uint64 val, uint64 enabled_bytes, void *aux) {
            // Watchdog reload value. Write side-effect: When INTEN bit in WDOGCONTROL is 0 and INTEN is set to 1, counter reloads from this register.
            if (!is_write_allowed()) {
                log warning: "Write to WDOGLOAD blocked due to lock";
                return;  // Ignore the write if locked
            }
            
            // Call default write behavior first
            default(val, enabled_bytes, aux);
            
            // Update the counter start value to the new load value
            counter_start_value = val;
            counter_start_time = SIM_cycle_count(dev.obj);
            
            // If timer is enabled, reschedule the timeout
            if (timer_enabled) {
                timeout_event.schedule_timeout();
            }
        }

        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            return this.val;
        }
    }
    register WDOGVALUE {
        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            // Current counter value. Read side-effect: Returns current value of watchdog counter, does not change the counter value.
            local cycles_t current_time = SIM_cycle_count(dev.obj);
            
            // Initialize counter_start_time on first access if not already done
            if (counter_start_time == 0) {
                counter_start_time = current_time;
            }
            
            local uint64 elapsed_cycles = current_time - counter_start_time;
            local uint32 step_value = WDOGCONTROL.step_value.val;
            local uint64 prescaler;
            
            // Calculate prescaler based on step_value field [4:2]
            switch (step_value) {
            case 0: prescaler = 1; break;   // ÷1
            case 1: prescaler = 2; break;   // ÷2
            case 2: prescaler = 4; break;   // ÷4
            case 3: prescaler = 8; break;   // ÷8
            case 4: prescaler = 16; break;  // ÷16
            default: prescaler = 1; break;  // Default to ÷1 if invalid
            }
            
            // Only decrement if the timer is enabled
            if (timer_enabled) {
                local uint64 effective_elapsed = elapsed_cycles / prescaler;
                if (effective_elapsed >= counter_start_value) {
                    return 0;  // Counter has reached zero and stayed there
                }
                return counter_start_value - effective_elapsed;
            } else {
                // If timer is not enabled, return the start value
                return counter_start_value;
            }
        }
    }
    register WDOGCONTROL {
        method write_register(uint64 val, uint64 enabled_bytes, void *aux) {
            // Control register for interrupt and reset enables and clock divider. Write side-effect: When INTEN bit is set to 1 after being previously disabled, reloads counter from WDOGLOAD.
            if (!is_write_allowed()) {
                log warning: "Write to WDOGCONTROL blocked due to lock";
                return;  // Ignore the write if locked
            }
            
            local bool old_inten = this.INTEN.val;
            local bool new_inten = (val & 1) != 0;
            
            // Call default write behavior first
            default(val, enabled_bytes, aux);
            
            // Check if INTEN transitioned from 0 to 1
            if (!old_inten && new_inten) {
                // Reload the counter from WDOGLOAD when INTEN transitions from 0 to 1
                counter_start_value = WDOGLOAD.val;
                counter_start_time = SIM_cycle_count(dev.obj);
                timer_enabled = true;
                
                // Schedule timeout if needed
                timeout_event.schedule_timeout();
            }
            
            // Update the timer_enabled state based on INTEN
            timer_enabled = this.INTEN.val;
            
            // If timer is enabled and running but we're changing the prescaler, reschedule the timeout
            if (timer_enabled && counter_start_value > 0) {
                timeout_event.schedule_timeout();
            }
        }

        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            return this.val;
        }
    }
    register WDOGINTCLR {
        method write_register(uint64 val, uint64 enabled_bytes, void *aux) {
            // Interrupt clear register. Write side-effect: Clears the interrupt signal (wdogint) and reloads counter from WDOGLOAD register. Any value written will trigger this behavior.
            if (!is_write_allowed()) {
                log warning: "Write to WDOGINTCLR blocked due to lock";
                return;  // Ignore the write if locked
            }
            
            // Call default write behavior first (though this is a write-only register)
            default(val, enabled_bytes, aux);
            
            // Clear the interrupt signal
            wdogint.signal_lower();
            
            // Clear interrupt pending state
            interrupt_pending = false;
            
            // Clear reset signal if it was active
            wdogres.signal_lower();
            reset_pending = false;
            
            // Update raw interrupt status to 0
            apb_bus.WDOGRIS.raw_watchdog_interrupt.val = 0;
            // apb_bus.WDOGMIS.watchdog_interrupt.val is computed on read, so no need to update here
            
            // Reload counter from WDOGLOAD
            counter_start_value = apb_bus.WDOGLOAD.val;
            counter_start_time = SIM_cycle_count(dev.obj);
            
            // Schedule the next timeout event if timer is enabled
            if (timer_enabled) {
                timeout_event.schedule_timeout();
            }
        }
    }
    register WDOGRIS {
        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            // Raw interrupt status register. Bit 0: Raw watchdog interrupt status (not affected by INTEN bit).
            return this.val;
        }
    }
    register WDOGMIS {
        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            // Masked interrupt status register. Bit 0: Masked interrupt status (WDOGRIS[0] AND WDOGCONTROL[0]).
            local uint64 ris_bit = apb_bus.WDOGRIS.raw_watchdog_interrupt.val & 1;
            local uint64 control_bit = apb_bus.WDOGCONTROL.INTEN.val & 1;
            local bool masked = (ris_bit != 0) && (control_bit != 0);
            local uint64 result = masked ? 1 : 0;
            return result;
        }
    }
    register WDOGLOCK {
        method write_register(uint64 val, uint64 enabled_bytes, void *aux) {
            // Write side-effect: Writing 0x1ACCE551 enables write access to other registers; writing any other value disables write access to other registers
            // Call default write behavior first
            default(val, enabled_bytes, aux);
            
            // Update lock state: 0x1ACCE551 unlocks, anything else locks
            if (val == 0x1ACCE551) {
                locked = false;
            } else {
                locked = true;
            }
        }

        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            // Read returns lock status: 0x0 for unlocked, 0x1 for locked
            if (locked) {
                return 0x1;  // When locked, return 1
            } else {
                return 0x0;  // When unlocked, return 0
            }
        }
    }
    register WDOGITCR {
        method write_register(uint64 val, uint64 enabled_bytes, void *aux) {
            // Integration test control register. Write side-effect: Controls entry/exit from integration test mode.
            if (!is_write_allowed()) {
                log warning: "Write to WDOGITCR blocked due to lock";
                return;  // Ignore the write if locked
            }
            
            // Call default write behavior first
            default(val, enabled_bytes, aux);
            
            // Update test mode based on bit 0
            test_mode = (val & 1) != 0;
        }

        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            // Integration test control register. Read returns current test mode state.
            local uint64 result = test_mode ? 1 : 0;
            return result;
        }
    }
    register WDOGITOP {
        method write_register(uint64 val, uint64 enabled_bytes, void *aux) {
            // Integration test output register. Write side-effect: In test mode, directly controls wdogint (bit 1) and wdogres (bit 0) outputs.
            if (!test_mode) {
                log warning: "Write to WDOGITOP ignored - not in test mode";
                return;  // Ignore writes when not in test mode
            }
            
            // Call default write behavior first
            default(val, enabled_bytes, aux);
            
            // Control wdogint (bit 1) and wdogres (bit 0) signals directly in test mode
            local bool wdogint_val = (val & 2) != 0;  // bit 1
            local bool wdogres_val = (val & 1) != 0;  // bit 0
            
            if (wdogint_val) {
                wdogint.signal_raise();
            } else {
                wdogint.signal_lower();
            }
            
            if (wdogres_val) {
                wdogres.signal_raise();
            } else {
                wdogres.signal_lower();
            }
        }

        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            // Integration test output register. Read returns current test output state.
            local uint64 result = 0;
            return result;
        }
    }
    register WDOGPERIPHID4 {
        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            // Peripheral ID register 4. Value should be 0x04.
            return 0x04;
        }
    }
    register WDOGPERIPHID5 {
        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            // Peripheral ID register 5. Value should be 0x00.
            return 0x00;
        }
    }
    register WDOGPERIPHID6 {
        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            // Peripheral ID register 6. Value should be 0x00.
            return 0x00;
        }
    }
    register WDOGPERIPHID7 {
        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            // Peripheral ID register 7. Value should be 0x00.
            return 0x00;
        }
    }
    register WDOGPERIPHID0 {
        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            // Peripheral ID register 0. Value should be 0x24.
            return 0x24;
        }
    }
    register WDOGPERIPHID1 {
        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            // Peripheral ID register 1. Value should be 0xB8.
            return 0xB8;
        }
    }
    register WDOGPERIPHID2 {
        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            // Peripheral ID register 2. Value should be 0x1B.
            return 0x1B;
        }
    }
    register WDOGPERIPHID3 {
        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            // Peripheral ID register 3. Value should be 0x00.
            return 0x00;
        }
    }
    register WDOGPCELLID0 {
        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            // PrimeCell ID register 0. Value should be 0x0D.
            return 0x0D;
        }
    }
    register WDOGPCELLID1 {
        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            // PrimeCell ID register 1. Value should be 0xF0.
            return 0xF0;
        }
    }
    register WDOGPCELLID2 {
        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            // PrimeCell ID register 2. Value should be 0x05.
            return 0x05;
        }
    }
    register WDOGPCELLID3 {
        method read_register(uint64 enabled_bytes, void *aux) -> (uint64) {
            // PrimeCell ID register 3. Value should be 0xB1.
            return 0xB1;
        }
    }
}

/*
 * Watchdog clock input signal.
 */
port wclk {
    implement signal {
        method signal_raise() {
        }
        method signal_lower() {
        }
    }
}
/*
 * Watchdog clock enable input signal.
 */
port wclk_en {
    implement signal {
        method signal_raise() {
        }
        method signal_lower() {
        }
    }
}
/*
 * Watchdog reset input signal (active low).
 */
port wrst_n {
    implement signal {
        method signal_raise() {
        }
        method signal_lower() {
        }
    }
}
/*
 * Peripheral reset input signal (active low).
 */
port prst_n {
    implement signal {
        method signal_raise() {
        }
        method signal_lower() {
        }
    }
}
/*
 * Watchdog interrupt signal. This signal is raised when the watchdog
 * timer reaches zero and the interrupt is enabled.
 */
connect wdogint {
    interface signal;
    method signal_raise() {
        this.signal.signal_raise();
    }
    method signal_lower() {
        this.signal.signal_lower();
    }
}
/*
 * Watchdog reset signal. This signal is raised to generate a system reset
 * when the watchdog timer reaches zero and reset functionality is enabled.
 */
connect wdogres {
    interface signal;
    method signal_raise() {
        this.signal.signal_raise();
    }
    method signal_lower() {
        this.signal.signal_lower();
    }
}

// USER-TODO: add other connect and port definitions here, if needed.

// Helper method to check if register writes are allowed based on lock state
method is_write_allowed() -> (bool) {
    return !locked || (apb_bus.WDOGLOCK.val == 0x1ACCE551);
}

// Event to handle timer timeout and interrupt generation
event timeout_event is simple_cycle_event {
    method event() {
        // Timer has reached zero - handle interrupt and reset logic
        local bool inten_enabled = apb_bus.WDOGCONTROL.INTEN.val;
        local bool resen_enabled = apb_bus.WDOGCONTROL.RESEN.val;
        
        if (inten_enabled) {
            // Set raw interrupt status
            apb_bus.WDOGRIS.raw_watchdog_interrupt.val = 1;
            
            // Raise interrupt signal if not already raised
            if (!interrupt_pending) {
                wdogint.signal_raise();
                interrupt_pending = true;
            }
        }
        
        // Check if reset should be enabled 
        // According to spec: Reset occurs when counter times out again after interrupt has occurred 
        // and RESEN=1. The interrupt must have already occurred (interrupt_pending true) and RESEN enabled.
        if (resen_enabled && interrupt_pending) {
            // Generate system reset when timer times out again with interrupt pending and reset enabled
            wdogres.signal_raise();
            reset_pending = true;
        }
        
        // At this point, the counter has reached zero and interrupt/reset actions have been triggered.
        // However, the timer should continue running in case of timeout for the reset functionality.
        // In a real implementation, the counter might stay at zero until cleared by writing to WDOGINTCLR.
        // For the reset to occur on a second timeout (as per spec), we need to check if the reset
        // functionality should reload the counter. Actually, the spec says that if the interrupt is not
        // cleared and the timer times out again, then reset occurs.
        // In our case, we'll keep the counter at zero but won't reschedule another timeout until 
        // the interrupt is cleared via WDOGINTCLR.
    }
    
    method schedule_timeout() {
        if (!obj) return;  // Exit if no object
        
        remove();  // Remove any existing event
        
        local uint64 current_counter_value = counter_start_value;
        
        // Only schedule if counter is greater than 0 and timer is enabled
        if (current_counter_value > 0 && timer_enabled) {
            local uint32 step_value = apb_bus.WDOGCONTROL.step_value.val;
            local uint64 prescaler;
            
            // Calculate prescaler based on step_value field [4:2]
            switch (step_value) {
            case 0: prescaler = 1; break;   // ÷1
            case 1: prescaler = 2; break;   // ÷2
            case 2: prescaler = 4; break;   // ÷4
            case 3: prescaler = 8; break;   // ÷8
            case 4: prescaler = 16; break;  // ÷16
            default: prescaler = 1; break;  // Default to ÷1 if invalid
            }
            
            local uint64 cycles_to_timeout = current_counter_value * prescaler;
            post(cycles_to_timeout);
        }
    }
}

// USER-TODO: add common methods here, if needed

// Initialize the device state
method init() {
    // Initialize internal state variables
    counter_start_value = 0xFFFFFFFF;  // Default reset value for WDOGLOAD
    timer_enabled = false;
    interrupt_pending = false;
    reset_pending = false;
    locked = false;  // Initially unlocked
    test_mode = false;
    
    // Set initial register values
    apb_bus.WDOGLOAD.val = 0xFFFFFFFF;
    apb_bus.WDOGVALUE.val = 0xFFFFFFFF;
    apb_bus.WDOGCONTROL.val = 0x00000000;
    apb_bus.WDOGINTCLR.val = 0x00000000;
    apb_bus.WDOGRIS.val = 0x00000000;
    apb_bus.WDOGMIS.val = 0x00000000;
    apb_bus.WDOGLOCK.val = 0x00000000;
    apb_bus.WDOGITCR.val = 0x00000000;
    apb_bus.WDOGITOP.val = 0x00000000;
}

method post_init() {
    // Any post-initialization setup
    // Set up the initial counter state based on register values
    counter_start_value = apb_bus.WDOGLOAD.val;
    // Initialize counter_start_time to a safe value; it will be set properly on first access
    counter_start_time = 0;
    timer_enabled = apb_bus.WDOGCONTROL.INTEN.val;
    
    // Schedule initial timeout if timer is enabled
    if (timer_enabled && counter_start_value > 0) {
        timeout_event.schedule_timeout();
    }
}
